Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
```

Ответ:
```
Вывод:
<nil>
false

Интерфейс хранит в себе тип интерфейса и тип самого значения.
В Go интерфейсный тип выглядит вот так:
type iface struct {
    tab  *itab
    data unsafe.Pointer
}

Где tab — это указатель на itable — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.
data — указывает на фактическую переменную с конкретным (статическим) типом.

Значение любого интерфейса, является nil в случае когда и значение, и тип являются nil.
В нашем случае значение (фактическая переменная) - nil, a тип - *os.PathError, информация о нем хранится в itable,
поэтому интерфейс не равен nil. Если сравнить с nil значение,
e, _ := err.(*os.PathError)
fmt.Println(e == nil)
то получим true.

метаданные выглядят так:
type itab struct {
	inter *interfacetype
	_type *_type
	hash  uint32 // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}

Поскольку эта таблица будет уникальна для каждой пары интерфейс-статический тип, 
то просчитывать её на этапе компиляции (early binding) будет нерационально и неэффективно.
Вместо этого, компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов, 
реализованных для данного типа. Аналогично генерируются метаданные со списком методов для каждого интерфейса. 
Теперь, во время исполнения программы, runtime Go может вычислить itable на лету (late binding) для каждой конкретной пары.
Этот itable кешируется, поэтому просчёт происходит только один раз.
Зная это, становится очевидно, почему Go ловит несоответствия типов на этапе компиляции, но кастинг к интерфейсу — во время исполнения. 
Поскольку у пустого интерфейса нет никаких методов, то и itable для него просчитывать и хранить не нужно — 
достаточно только метаинформации о статическом типе.
